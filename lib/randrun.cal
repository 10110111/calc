/*
 * randrun - perform a run test on rand()
 *
 * If X(j) < X(j+1) < ... X(j+k) >= X(j+k+1), then we have a run of 'k'.
 * We ignore the run breaker, X(j+k+1), and start with X(j+k+2) when
 * considering a new run in order to make our runs chi independent.
 *
 * See Knuth's "Art of Computer Programming - 2nd edition",
 * Volume 2 ("Seminumerical Algorithms"), Section 3.3.2.
 * "G. Run test", pp. 65-68,
 * "problem #14", pp. 74, 536.
 *
 * We use the suggestion in problem #14 to allow an application of the
 * chi-square test and to make estimating the run length probs easy.
 */
/*
 * Copyright 1995 by Landon Curt Noll.	All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software and
 * its documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright, this permission notice, and the
 * disclaimer below appear in all of the following:
 *
 *	* supporting documentation
 *	* source copies
 *	* source works derived from this source
 *	* binaries derived from this source or from derived source
 *
 * LANDON CURT NOLL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL LANDON CURT NOLL BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

define randrun(run_cnt)
{
    local i;			/* index */
    local max_run;		/* longest run */
    local long_run_cnt;		/* number of runs longer than MAX_RUN */
    local run;			/* current run length */
    local tally_sum;		/* sum of all tally values */
    local last;			/* last random number */
    local current;		/* current random number */
    local MAX_RUN = 9;		/* max run we will keep track of */
    local mat tally[1:MAX_RUN]; /* tally of length of a rise run of 'x' */
    local mat prob[1:MAX_RUN];	/* prob[x] = probability of 'x' length run */

    /*
     * parse args
     */
    if (param(0) == 0) {
	run_cnt = 65536;
    }

    /*
     * run setup
     */
    max_run = 0;		/* no runs yet */
    long_run_cnt = 0;		/* no long runs set */
    current = rand();		/* our first number */
    run = 1;

    /*
     * compute the run length probabilities
     *
     * A run length of 'r' occurs with a probability of:
     *
     *			1/r! - 1/(r+1)!
     */
    for (i=1; i <= MAX_RUN; ++i) {
	prob[i] = 1.0/fact(i) - 1.0/fact(i+1);
    }

    /*
     * look at a number of random number trials
     */
    for (i=0; i < run_cnt; ++i) {

	/* get our current number */
	last = current;
	current = rand();

	/* look for a run break */
	if (current < last) {

	    /*	record the stats */
	    if (run > max_run) {
		max_run = run;
	    }
	    if (run > MAX_RUN) {
		++long_run_cnt;
	    } else {
		++tally[run];
	    }

	    /* start a new run */
	    current = rand();
	    run = 1;

	/* note the continuing run */
	} else {
	    ++run;
	}
    }
    /* determine the number of runs found */
    tally_sum = matsum(tally) + long_run_cnt;

    /*
     * print the stats
     */
    printf("rand run test used %d values to produce %d runs\n",
      run_cnt, tally_sum);
    for (i=1; i <= MAX_RUN; ++i) {
	printf("length=%d\tprob=%9.7f\texpect=%d \tcount=%d \terr=%9.7f\n",
	  i, prob[i], round(tally_sum*prob[i]), tally[i],
	  (tally[i] - round(tally_sum*prob[i]))/tally_sum);
    }
    printf("length>%d\t\t\t\t\tcount=%d\n", MAX_RUN, long_run_cnt);
    printf("max length=%d\n", max_run);
}

if (config("lib_debug") & 3) {
    print "randrun([run_length]) defined";
}
